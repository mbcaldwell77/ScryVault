# Replit Agent Task: User Authentication & Security Implementation

## ðŸš¨ CRITICAL PRIORITY: SECURE THE DATABASE

**Context:** ScryVault's database is currently publicly accessible to anyone with the URL. This is a MAJOR security vulnerability that needs immediate resolution.

---

## **MISSION OBJECTIVE**

Implement a complete user authentication system that:
1. Secures all API endpoints with proper authentication
2. Isolates user data so each user only sees their own inventory
3. Provides a login/registration system with JWT tokens
4. Maintains all existing functionality while adding security

---

## **TECHNICAL REQUIREMENTS**

### **1. Database Schema Updates**

Add user management tables to the existing schema:

```sql
-- Add to shared/schema.ts

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  email: text("email").notNull().unique(),
  passwordHash: text("password_hash").notNull(),
  firstName: text("first_name"),
  lastName: text("last_name"),
  subscriptionTier: text("subscription_tier").notNull().default("free"), // "free", "basic", "pro", "business", "enterprise"
  isActive: boolean("is_active").notNull().default(true),
  emailVerified: boolean("email_verified").notNull().default(false),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const userSessions = pgTable("user_sessions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  token: text("token").notNull().unique(),
  refreshToken: text("refresh_token").notNull().unique(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

// Modify existing books table to include user_id
export const books = pgTable("books", {
  // ... existing fields ...
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  // ... rest of existing fields unchanged ...
});
```

### **2. Authentication Middleware**

Create `server/auth-middleware.ts`:

```typescript
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';
import { db } from './db';
import { users, userSessions } from '@shared/schema';
import { eq, and, gt } from 'drizzle-orm';

export interface AuthenticatedRequest extends Request {
  user?: {
    id: number;
    email: string;
    subscriptionTier: string;
  };
}

export const authenticateToken = async (
  req: AuthenticatedRequest, 
  res: Response, 
  next: NextFunction
) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
    
    // Verify session is still valid
    const session = await db.select()
      .from(userSessions)
      .where(and(
        eq(userSessions.token, token),
        gt(userSessions.expiresAt, new Date())
      ))
      .limit(1);

    if (session.length === 0) {
      return res.status(401).json({ error: 'Invalid or expired token' });
    }

    // Get user details
    const user = await db.select()
      .from(users)
      .where(eq(users.id, decoded.userId))
      .limit(1);

    if (user.length === 0 || !user[0].isActive) {
      return res.status(401).json({ error: 'User not found or inactive' });
    }

    req.user = {
      id: user[0].id,
      email: user[0].email,
      subscriptionTier: user[0].subscriptionTier
    };

    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid token' });
  }
};
```

### **3. Authentication Routes**

Create `server/auth-routes.ts`:

```typescript
import { Router } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { db } from './db';
import { users, userSessions } from '@shared/schema';
import { eq } from 'drizzle-orm';
import { z } from 'zod';

const router = Router();

const registerSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  firstName: z.string().optional(),
  lastName: z.string().optional()
});

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string()
});

// Register new user
router.post('/register', async (req, res) => {
  try {
    const { email, password, firstName, lastName } = registerSchema.parse(req.body);

    // Check if user already exists
    const existingUser = await db.select()
      .from(users)
      .where(eq(users.email, email))
      .limit(1);

    if (existingUser.length > 0) {
      return res.status(400).json({ error: 'User already exists' });
    }

    // Hash password
    const passwordHash = await bcrypt.hash(password, 12);

    // Create user
    const newUser = await db.insert(users).values({
      email,
      passwordHash,
      firstName,
      lastName
    }).returning();

    // Generate tokens
    const accessToken = jwt.sign(
      { userId: newUser[0].id }, 
      process.env.JWT_SECRET!, 
      { expiresIn: '1h' }
    );
    
    const refreshToken = jwt.sign(
      { userId: newUser[0].id }, 
      process.env.JWT_REFRESH_SECRET!, 
      { expiresIn: '7d' }
    );

    // Store session
    await db.insert(userSessions).values({
      userId: newUser[0].id,
      token: accessToken,
      refreshToken,
      expiresAt: new Date(Date.now() + 60 * 60 * 1000) // 1 hour
    });

    res.status(201).json({
      user: {
        id: newUser[0].id,
        email: newUser[0].email,
        firstName: newUser[0].firstName,
        lastName: newUser[0].lastName,
        subscriptionTier: newUser[0].subscriptionTier
      },
      accessToken,
      refreshToken
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

// Login user
router.post('/login', async (req, res) => {
  try {
    const { email, password } = loginSchema.parse(req.body);

    // Find user
    const user = await db.select()
      .from(users)
      .where(eq(users.email, email))
      .limit(1);

    if (user.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Verify password
    const isValidPassword = await bcrypt.compare(password, user[0].passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Generate tokens
    const accessToken = jwt.sign(
      { userId: user[0].id }, 
      process.env.JWT_SECRET!, 
      { expiresIn: '1h' }
    );
    
    const refreshToken = jwt.sign(
      { userId: user[0].id }, 
      process.env.JWT_REFRESH_SECRET!, 
      { expiresIn: '7d' }
    );

    // Store session
    await db.insert(userSessions).values({
      userId: user[0].id,
      token: accessToken,
      refreshToken,
      expiresAt: new Date(Date.now() + 60 * 60 * 1000) // 1 hour
    });

    res.json({
      user: {
        id: user[0].id,
        email: user[0].email,
        firstName: user[0].firstName,
        lastName: user[0].lastName,
        subscriptionTier: user[0].subscriptionTier
      },
      accessToken,
      refreshToken
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// Logout
router.post('/logout', async (req, res) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token) {
      await db.delete(userSessions).where(eq(userSessions.token, token));
    }

    res.json({ message: 'Logged out successfully' });
  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ error: 'Logout failed' });
  }
});

export default router;
```

### **4. Secure Existing API Routes**

Update `server/routes.ts`:

```typescript
import { authenticateToken, AuthenticatedRequest } from './auth-middleware';
import authRoutes from './auth-routes';

// Add auth routes
app.use('/api/auth', authRoutes);

// Protect all book routes
app.use('/api/books', authenticateToken);

// Update book routes to filter by user
app.get("/api/books", async (req: AuthenticatedRequest, res) => {
  try {
    const books = await storage.getAllBooksForUser(req.user!.id);
    res.json(books);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch books" });
  }
});

// Update all other book routes similarly...
```

### **5. Update Storage Layer**

Update `server/storage.ts` to include user-specific methods:

```typescript
async getAllBooksForUser(userId: number): Promise<Book[]> {
  return await db.select().from(books)
    .where(eq(books.userId, userId))
    .orderBy(books.dateAdded);
}

async createBookForUser(userId: number, book: InsertBook): Promise<Book> {
  const timestamp = Date.now().toString().slice(-6);
  const isbnSuffix = book.isbn.slice(-4);
  const sku = `${isbnSuffix}-${timestamp}`;
  
  const bookWithUserAndSku = {
    ...book,
    userId,
    sku
  };
  
  const [newBook] = await db
    .insert(books)
    .values(bookWithUserAndSku)
    .returning();
  return newBook;
}

// Update all other methods to include userId filtering...
```

### **6. Frontend Authentication**

Create `client/src/hooks/use-auth.ts`:

```typescript
import { useState, useEffect, createContext, useContext } from 'react';

interface User {
  id: number;
  email: string;
  firstName?: string;
  lastName?: string;
  subscriptionTier: string;
}

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  register: (email: string, password: string, firstName?: string, lastName?: string) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

// Add token management, API interceptors, etc.
```

Create login/register pages and update the app routing to require authentication.

---

## **ENVIRONMENT VARIABLES**

Add to `.env`:

```
JWT_SECRET=your-super-secret-jwt-key-here
JWT_REFRESH_SECRET=your-super-secret-refresh-key-here
```

---

## **TESTING CHECKLIST**

After implementation, verify:

1. âœ… New users can register with email/password
2. âœ… Existing users can log in (after migration)
3. âœ… Users can only see their own books in inventory
4. âœ… All API endpoints require authentication
5. âœ… Tokens expire and refresh properly
6. âœ… Logout invalidates sessions
7. âœ… Password hashing is secure (bcrypt with salt)
8. âœ… SQL injection protection via parameterized queries

---

## **DATA MIGRATION**

Since we're adding user authentication to existing data:

1. **Create a default admin user** for existing books
2. **Assign all current books to this user** 
3. **Provide migration script** to reassign books if needed

---

## **SUCCESS CRITERIA**

- [ ] Database is no longer publicly accessible
- [ ] User registration/login system working
- [ ] All existing inventory functionality preserved
- [ ] Users can only access their own data
- [ ] Secure password handling implemented
- [ ] Session management working properly
- [ ] Frontend authentication flow complete

---

## **PRIORITY ORDER**

1. **Database schema updates** (add users tables, modify books table)
2. **Authentication middleware** (protect API routes)
3. **Auth routes** (register/login/logout endpoints)
4. **Update existing routes** (add user filtering)
5. **Frontend auth system** (login/register pages, token management)
6. **Data migration** (handle existing books)
7. **Testing & validation**

**Time Estimate:** 5-7 days for complete implementation and testing

**Dependencies:** 
- `bcrypt` for password hashing
- `jsonwebtoken` for JWT tokens
- Environment variables for secrets

Go secure that database, Agent! This is mission-critical stuff. ðŸ”’